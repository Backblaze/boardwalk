"""
This type stub file was generated by pyright.
"""

import io

"""Base64 stream with context manager support."""
LOGGER_NAME = ...
__all__ = ("Base64IO",)
__version__ = ...
_LOGGER = ...

class Base64IO(io.IOBase):
    """Base64 stream with context manager support.

    Wraps a stream, base64-decoding read results before returning them and base64-encoding
    written bytes before writing them to the stream. Instances
    of this class are not reusable in order maintain consistency with the :class:`io.IOBase`
    behavior on ``close()``.

    .. note::

        Provides iterator and context manager interfaces.

    .. warning::

        Because up to two bytes of data must be buffered to ensure correct base64 encoding
        of all data written, this object **must** be closed after you are done writing to
        avoid data loss. If used as a context manager, we take care of that for you.

    :param wrapped: Stream to wrap
    """

    closed = ...
    def __init__(self: Base64IO, wrapped: IO) -> None:
        """Check for required methods on wrapped stream and set up read buffer.

        :raises TypeError: if ``wrapped`` does not have attributes needed to determine the stream's state
        """
        ...
    def __enter__(self) -> Base64IO:
        """Return self on enter."""
        ...
    def __exit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc_value: Optional[BaseException],
        traceback: Optional[TracebackType],
    ) -> Literal[False]:
        """Properly close self on exit."""
        ...
    def close(self) -> None:
        """Close this stream, encoding and writing any buffered bytes is present.

        .. note::

            This does **not** close the wrapped stream.
        """
        ...
    def writable(self) -> bool:
        """Determine if the stream can be written to.

        Delegates to wrapped stream when possible.
        Otherwise returns False.

        :rtype: bool
        """
        ...
    def readable(self) -> bool:
        """Determine if the stream can be read from.

        Delegates to wrapped stream when possible.
        Otherwise returns False.

        :rtype: bool
        """
        ...
    def flush(self) -> None:
        """Flush the write buffer of the wrapped stream."""
        ...
    def write(self, b: bytes) -> int:
        """Base64-encode the bytes and write them to the wrapped stream.

        Any bytes that would require padding for the next write call are buffered until the
        next write or close.

        .. warning::

            Because up to two bytes of data must be buffered to ensure correct base64 encoding
            of all data written, this object **must** be closed after you are done writing to
            avoid data loss. If used as a context manager, we take care of that for you.

        :param bytes b: Bytes to write to wrapped stream
        :raises ValueError: if called on closed Base64IO object
        :raises IOError: if underlying stream is not writable
        """
        ...
    def writelines(self, lines: Iterable[bytes]) -> None:
        """Write a list of lines.

        :param list lines: Lines to write
        """
        ...
    def read(self, b: int = ...) -> bytes:
        """Read bytes from wrapped stream, base64-decoding before return.

        .. note::

            The number of bytes requested from the wrapped stream is adjusted to return the
            requested number of bytes after decoding returned bytes.

        :param int b: Number of bytes to read
        :returns: Decoded bytes from wrapped stream
        :rtype: bytes
        """
        ...
    def __iter__(self):  # -> Self@Base64IO:
        """Let this class act as an iterator."""
        ...
    def readline(self, limit: int = ...) -> bytes:
        """Read and return one line from the stream.

        If limit is specified, at most limit bytes will be read.

        .. note::

            Because the source that this reads from may not contain any OEL characters, we
            read "lines" in chunks of length ``io.DEFAULT_BUFFER_SIZE``.

        :param int limit: Maximum number of bytes to read
        :rtype: bytes
        """
        ...
    def readlines(self, hint: int = ...) -> List[bytes]:
        """Read and return a list of lines from the stream.

        ``hint`` can be specified to control the number of lines read: no more lines will
        be read if the total size (in bytes/characters) of all lines so far exceeds hint.

        :param int hint: Number of lines to read
        :returns: Lines of data
        :rtype: list of bytes
        """
        ...
    def __next__(self) -> bytes:
        """Python 3 iterator hook."""
        ...
